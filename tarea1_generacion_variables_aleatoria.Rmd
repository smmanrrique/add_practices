---
title: "tarea1_generacion_variables_aleatoria"
author: "Shamuel Manrrique"
nip: "802400"
date: "10/25/2020"
output:
  html_document: default
  pdf_document: default
---

# Practica 1 

Aplicar el método de la transformación inversa y/o el de aceptación rechazo para construir una función en R que genere datos de la siguientes distribuciones:

5. **Distribución log exponencial-geométrica (Jodra y Jimenez, 2020)** de parámetros α > 0 y β > 0 con función de densidad: 
´
f(x; α, β) = (α(1 + β)x^(α−1))/(1 + β x^α)^2, 0 < x < 1

## Metodo de transformacion Inversa
Buscamos la integral de la función de densidad para obtener la funcion de distribucion acumulado

>f(x; α, β) = (1 + β) x^(α - 1))/(1 + β x^α)^2 , 0 < x < 1, α > 0, β > 0

1. Integramos la funcion usando WolframAlpha<https://www.wolframalpha.com/>

>integral(α (1 + β) x^(α - 1))/(1 + β x^α)^2 dx = (1 + β)x^α/(1 + β x^α)

2. La función de distribución acumulada es:

>F(x; α, β) = (1 + β)x^α/(1 + β x^α)    , 0 < x < 1


3. Buscamos la función inversa de la función de distribución acumulada

>inverse y = ((1 + β)x^α)/(1 + β x^α)  , 0 < x < 1, α > 0, β > 0

4. La función inversa de F o función cuantil es:

>F(u; α, β)=(-u /(βu- β-1))^(1/α),  0 < u < 1

5. Programa en R para crear muestras aleatoria siguiendo la Distribución log exponencial-geométrica

### Importar librerías necesarias
```{r setup, error=FALSE, include=FALSE}
library("ggplot2")
library("dplyr")          # load
library("RcmdrMisc")
```

### Creamos la Función 
```{r}

# Definimos función para generar variables aleatoria siguiendo 
# la Distribución log exponencial-geométrica (Jodra y Jimenez, 2020)
DatosJoJi <- function(α,β,n){
  # La función recibe los parámetros
  # α -> valor deseado para alpha
  # β -> valor deseado para beta
  # n -> tamaño del vector de variables aleatorias que quieren generar
  
  # Generar "n" datos uniforme (0,1):
  VectorUnif<-runif(n,0,1)
  
  # Generar datos de la Distribución log exponencial-geométrica (Jodra y Jimenez, 2020)
  # mediante la función cuantil:
  
  return ((- VectorUnif /( β * VectorUnif - β - 1))^(1/α))
  #return(((β*(-VectorUnif) - 1)/(β^2*(VectorUnif - 1)))^(1/α))

}

# Definimos la Función de densidad PdfX para validar la correctitud de 
# las variables aleatorias creadas con la función DatosJoJi 
PdfX<- function(x,n){(n/10)*(α*(1 + β)*x^(α-1))/(1 + β*x^α)^2 }


# Declaramos los valores de α,β,n
α=3; 
β=2;
n=1000;

# Llamamos la funcion DatosJoJi con sus respectivos parametros
Dist_log_exp_geometrica <- DatosJoJi(α,β,n)

# Graficamos un histograma con las variables obtenidas
Hist(Dist_log_exp_geometrica, scale="frequency", breaks="Sturges", col="darkgray")

# Añadimos la curva de validacion a la grafica
curve(PdfX(x,n), from=0, to=1.0, lwd=2, cex = 1.1, col="red",add=TRUE)

```


```{r}
# Generar datos con densidad: f(x)=2*sqrt(x)*exp(-x)/sqrt(pi), x>0.
# Tomar g(x)=(2/3)*exp(-(2/3)*x), x>0. # Max x{f(x)/cg(x)} en x=3/2.
c<-3^(3/2)*(2*pi*exp(1))^(-1/2)
# Funcion para generar Num datos con densidad f(x):
DatosPdfX<-function(Num){
  Aceptados<-rep(0,Num); i<-1
  while(i<=Num){
    y<-rexp(1,2/3); u<-runif(1,0,1)
    if (u<c*(3*exp(-(1/3)*y)*sqrt(y)/sqrt(pi))){
      Aceptados[i]<-y; i<-i+1} }
    return(Aceptados)
}

Generados<-DatosPdfX(10000)
library(RcmdrMisc)
Hist(Generados,col="blue", scale="density",xlab="x")
PdfX<- function(x){2*sqrt(x)*exp(-x)/sqrt(pi)}
curve(PdfX(x), from=0, to=10, lwd=2, cex = 1.1, col="red", add=TRUE)

```
```{r}

DatosWeibull<-function(alpha,beta,m){
VectorUnif<-runif(m,0,1) # Generar "m" datos uniforme (0,1)
# Datos Weibull mediante transformacion de datos exponenciales11
DataSet<- (-beta * log(1-VectorUnif))^ (1/alpha)
return(DataSet)}
library(RcmdrMisc)
Hist(DatosWeibull(3,2,10000),col="blue", scale="density",xlab="x")
#Funcion de densidad:
alpha=3; beta=2

PdfX<- function(x){ (alpha/beta)*x^(alpha-1)*exp(-x^(alpha/beta)) }

curve(PdfX(x), from=0, to=15, lwd=4, cex = 1.1, col="red",add=TRUE)


```
